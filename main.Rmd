---
title: "Stat 854 Project: Mirror-match Bootstrap"
author: "authors"
date: "April 14 2024"
output: 
  pdf_document
papersize: a4
urlcolor: blue
fontsize: 11pt    
fontfamily: mathpple
bibliography: references.bib
---



\newcommand\bx{\boldsymbol x}
\newcommand\btheta{\boldsymbol \theta}
\newcommand\bSigma{\boldsymbol \Sigma}
\newcommand\bmu{\boldsymbol \mu}
\newcommand\expect{\text{E}}
\newcommand\prob{\text{Pr}}
\newcommand\bI{\boldsymbol I}
\newcommand{\bm}[1]{\boldsymbol{\mathbf{#1}}}

# Experiments

# 1. We pre-process the syc.txt in SAS, where 
+ we deal with missing values in the 8 variables mentioned in A2Q4 by setting missing values as '.'
+ we keep only the necessary columns, i.e. the 8 variables mentioned in A2Q4
+ sort the dataset by stratum in an ascending order
+ export a syc dataset called syc_sas.csv with 8 variables for calculation in SAS
+ export another syc dataset call syc_r.csv with 2 variables (stratum, finalwt) for computing bootstrap weight in R

In addition, PROC FREQ is used to generate frequency counts for the stratum variable.   


## SAS code 
```{r echo=FALSE, fig.align='left', out.width = "100%"}
knitr::include_graphics("figures/sas_1.pdf")

``` 

## SAS output
```{r echo=FALSE, fig.align='center', out.width = "120%"}
knitr::include_graphics("figures/sas_2.pdf")

``` 

# 2. We read in the syc in R and log the $N_h$ information provided in A2Q4
```{r, eval=TRUE, echo=TRUE}
# Read in the Survey of Youth in Custody
syc <- readr::read_csv(
  file = "data/syc_r.csv", # Tell it where the file is
  col_types = "nn", # Tell it that there are two columns, and they are "numeric" (n)
)

# Read the stratum size provided in Assignment 2 Question 4, shape (16, 1)
N_h_list = c(2724, 3192, 4107, 2705, 3504, 376, 56, 
             528, 624, 520, 672, 384, 744, 847, 824, 1848)

# glimpse the read data set
dplyr::glimpse(syc)
```

## Extra step: rescaling *finalwt* variable
As can be seen from the code below, the sum of finalwt in each stratum is different from $N_h$. Therefore, we rescale the finalwt to make the sum of finalwt in each stratum to be equal to N_h, based on the R code provided by Professor Boudreau (here we sincerely thank him for helping us with the project and providing us with the code).  

```{r, eval=TRUE}
finalwt_h_list = c()
for (h in 1:16)
{
  sub_dataset = syc[syc$stratum == h, ]
  finalwt_h = sum(sub_dataset$finalwt)
  finalwt_h_list = c(finalwt_h_list, finalwt_h)
}

# Comparison
comparison_df <- data.frame(finalwt_h_sum = finalwt_h_list, N_h = N_h_list)
print(comparison_df)

# we want the sum of finalwt in each stratum to be equal to N_h
# therefore, we rescale it
finalwt2 = c()
for (h in 1:16)
{
  finalwt_h = syc[syc$stratum == h, ]$finalwt
  N_h = N_h_list[h]
  finalwt_h_sum = finalwt_h_list[h]
  finalwt_h = finalwt_h * N_h / finalwt_h_sum
  finalwt2 = c(finalwt2, finalwt_h)
}

syc$finalwt = finalwt2
```

```{r}
# Make sure rescaling is complete 
finalwt_h_list = c()
for (h in 1:16)
{
  sub_dataset = syc[syc$stratum == h, ]
  finalwt_h = sum(sub_dataset$finalwt)
  finalwt_h_list = c(finalwt_h_list, finalwt_h)
}

# Comparison
comparison_df <- data.frame(finalwt_h_sum = finalwt_h_list, N_h = N_h_list)
print(comparison_df)

```




# 3. We write the function for performing one mirror-match bootstrap for stratum h
For $n_{h}^{\prime}$, we choose 

\begin{equation} \label{eq:1}
n_{h}^{\prime} = f_h \times n_h,
\end{equation}

advised by author in the paper [@sitter1992comparing], where $f_h = \frac{n_h}{N_h}$, so that the first two moments of the distribution of the bootstrap estimate of $\bar{y}$ match the usual unbiased estimates of the first two moments of $\bar{y}$.  

## Selection for $n_{7}^{\prime}$
However, in the actual implementation, we found that for stratum $7$, the $n_{7}^{\prime}$ computed using Equation $\eqref{eq:1}$ gave us a value that is less than $1$, while the range of $n_{h}^{\prime}$ must be in $[1, n_h)$.  

Therefore, we randomly select the $n_{7}^{\prime}$ among the $\{1, 2\}$ (with equal probability) in each bootstrap independently. For the other $15$ strata, the average value of $n_{h}^{\prime} / n_h$ computed using $\eqref{eq:1}$ is approx. $0.12$. Hence, we choose the range $\{1, 2\}$ to approximate this proportion given $n_{7}$ is 7.  

Other than stratum 7, the $n_{h}^{\prime}$ of all the other strata calculated using Equation $\eqref{eq:1}$ works well and is in the range $[1, n_h)$.  

## Randomization of $n_{h}^{\prime}$
For stratum $h$ in each bootstrap, the $n_{h}^{\prime}$ is a random variable with discrete distribution across \{$n_{h, floor}^{\prime}$, $n_{h, ceil}^{\prime}$ \} whose pmf is given below:
$$
Pr(n_{h}^{\prime} = n_{h, floor}^{\prime}) = n_{h, ceil}^{\prime} - n_{h}^{\prime} = p,
$$
and $Pr(n_{h}^{\prime} = n_{h, ceil}^{\prime})$ is:
$$
Pr(n_{h}^{\prime} = n_{h, ceil}^{\prime}) = 1 - p,
$$
where $n_{h, floor}^{\prime}$ is equal to `floor(n_h_prime)` in R; $n_{h, ceil}^{\prime}$ is equal to `ceiling(n_h_prime)` in R.  
The randomization is done at the beginning of a bootstrap for each stratum $h$ independently and repeated at each bootstrap as described in the paper [@sitter1992resampling].  



## Randomization of $k_h$
For stratum $h$ in each bootstrap, given the value of $n_{h}^{\prime}$ obtained in the randomization above, the $k_h$ is a random variable with discrete distribution across \{$k_{h, floor}$, $k_{h, ceil}$\} whose pmf is described below:
$$
Pr(k_h = k_{h, floor}) = \frac{\bigg( \frac{1}{k_h} - \frac{1}{k_{h, ceil}}\bigg) }{\bigg( \frac{1}{k_{h, floor}} - \frac{1}{k_{h, ceil}} \bigg)} = p_h,
$$
and $Pr(k_h = k_{h, ceil})$ is:
$$
Pr(k_h = k_{h, ceil}) = 1 - p_h,
$$
where $k_{h, floor}$ is equal to `floor(k_h)` in R; $k_{h, ceil}$ is equal to `ceiling(k_h)` in R.  
The randomization is done independently for each stratum $h$ and repeated at each bootstrap as described in the paper [@sitter1992resampling].  



```{r, eval=TRUE, echo=TRUE}
mirror_match_bootstrap_h = function(dataset, N_h_list, h)
  # Perform one mirror-match bootstrap for stratum h
  # parameters
  # ---------
  # 
  # dataset : data.frame
  #   dataset of shape (n, 2)
  # N_h_list : vector
  #   vector of shape (16, 1)
  # h : int
  #   stratum number
  #
  # return
  # ------
  #
  # bootstrap_weights : vector
  #   bootstrap weights for the sample units in the stratum (from 1 to n_h)
  #   shape (n_h, 1)

{
  # get the stra_weights df, shape is (n_h, 2)
  stra_weights_df = get_stratum(dataset, h)
  # get the stra_weights vector, shape is (n_h, 1)
  stra_weights = stra_weights_df$finalwt
  # get n_h from the dimension of stra_weights_df
  n_h = dim(stra_weights_df)[1]
  # get N_h from the N_h_list
  N_h = N_h_list[h]
  # compute the n_h_prime using the formula n_{h}^{\prime} = f_n \times n_h
  n_h_prime = n_h * (n_h / N_h)
  # get random integer n_h_prime by applying random_n_h_prime if it is not integer
  if (!n_h_prime %% 1 == 0)
  {
    n_h_prime = random_n_h_prime(n_h_prime, n_h, h)
  }
  # compute k_h
  k_h = get_k_h(n_h, n_h_prime, N_h)
  # create a vector of indices for the stra_weights, shape is (n_h, 1)
  indices = seq(1, n_h)
  # create a counter to count the number of times a index is selected, shape is (n_h, 1)
  counter = rep(0, n_h)
  # print information about the stratum h
  # print(paste("The stratum is", h, "the n_h is", n_h, "the n_h_prime is", n_h_prime, "the k_h is", k_h))
  
  # carry out sample without replacement from indices (k_h times), sample size is n_h_prime
  for (s in 1:k_h)
  {
    # sample without replacement
    bootstrapsample = sample(indices, n_h_prime, replace = FALSE)
    for (index in bootstrapsample)
    {
      # log the number of appearances of index of elements in stratum h in the bootstrapsample
      counter[index] = counter[index] + 1
    }
  }
  # calculate the bootstrap weights using stra_weights (n_h, 1) and counter (n_h, 1)
  # apply element-wise multiplication of the two vectors
  bootstrap_weights = counter * stra_weights
  
  # make sure the length of bootstrap_weights is n_h
  if (length(bootstrap_weights) == n_h)
  {
    return(bootstrap_weights)
  }
  else
  {
    stop("bootstrap_weights does not have length n_h")
  }
  
}

get_stratum = function(dataset, h)  # get the weights of stratum h from the dataset
{
  # make sure stratum number is in the range of 1 to 16
  if (h %in% seq(1, 16))
  {
    # get the weights of stratum h from the dataset
    stra_weights_df = dataset[dataset$stratum == h, ]
    return(stra_weights_df)
  }
  else
  {
    stop("Stratum number does not exist.")
  }
}

get_k_h = function(n_h, n_h_prime, N_h)  # compute the k_h, the number of resamplings with replacement
{
  f_h = n_h / N_h  # compute f_h
  f_h_star = n_h_prime / n_h  # compute f_h_star
  k_h = (n_h * (1 - f_h_star)) / (n_h_prime * (1 - f_h))  # compute k_h using the formula
  # apply the random_k_h function if k_h is not integer
  
  if (!k_h%%1 == 0)
  {
    k_h = random_k_h(k_h)
  }
  return(k_h)
}

random_n_h_prime = function(n_h_prime, n_h, h)  # randomization for k_h
{
  # make sure n_h_prime is in the proper range
  if (n_h_prime >= 1 && n_h_prime < n_h)
  {
    # get k_h_floor and k_h_ceil
    n_h_prime_floor = floor(n_h_prime)
    n_h_prime_ceil = ceiling(n_h_prime)
    
    # get prob for n_h_prime_floor
    # apply the formula in the paper
    p_floor = n_h_prime_ceil - n_h_prime
    # get prob for k_h_ceil
    p_ceil = 1 - p_floor
    
    # get the random integer n_h_prime based on the p_floor and p_ceil
    n_h_prime = sample(c(n_h_prime_floor, n_h_prime_ceil), 1, prob = c(p_floor, p_ceil))
    return(n_h_prime)
  }
  else if (h == 7)
  {
    n_h_prime = sample(c(1, 2), 1)
    return(n_h_prime)
  }
  else
  {
    stop(paste("n_h_prime must be larger than or equal to 1 and less than n_h, however got", n_h_prime))
  }
}

random_k_h = function(k_h)  # randomization for k_h
{
  # make sure k_h is larger than 1
  if (k_h >= 1)
  {
    # get k_h_floor and k_h_ceil
    k_h_floor = floor(k_h)
    k_h_ceil = ceiling(k_h)
    
    # get prob for k_h_floor
    # apply the formula in the paper
    p_floor = ((1 / k_h) - (1 / k_h_ceil)) / ((1 / k_h_floor) - (1 / k_h_ceil))
    # get prob for k_h_ceil
    p_ceil = 1 - p_floor
    
    # get the random integer k_h based on the p_floor and p_ceil
    k_h = sample(c(k_h_floor, k_h_ceil), 1, prob = c(p_floor, p_ceil))
    return(k_h)
  }
  else
  {
    stop("k_h must be larger than or equal to 1")
  }
}

weights = mirror_match_bootstrap_h(syc, N_h_list, 3)
weights

```
# 4. We perform one complete bootstrap for the sample of size $n$. Specifically, we perform bootstrap for all the 16 strata in the sample. 

```{r, eval = TRUE, echo = TRUE}
mirror_match_bootstrap_full = function(dataset, N_h_list, stratum_list = seq(1, 16))
{
  # Perform one full mirror-match bootstrap for 16 strata
  # parameters
  # ---------
  # 
  # dataset : data.frame
  #   dataset of shape (n, 2)
  # N_h_list : vector
  #   vector of shape (16, 1)
  # stratum_list : vector
  #   list contatining all the stratum numbers
  #   default is seq(1, 16)
  #
  # return
  # ------
  #
  # bootstrap_weights : vector
  #   bootstrap weights for the full sample of size n consisting of 16 strata
  #   shape (n, 1)

  # compute the sample size n
  n = dim(dataset)[1]
  # create an empty vector for storing bootstrap weights
  bootstrap_weights_full = c()
  for (h in stratum_list)
  {
    # obtain the bootstrap weights for stratum h by applying the function mirror_match_bootstrap_h
    bootstrap_weights_h = mirror_match_bootstrap_h(dataset, N_h_list, h)
    # concatenate the new bootstrap weights to the bootstrap_weights_full
    bootstrap_weights_full = c(bootstrap_weights_full, bootstrap_weights_h)
  }
  
  # make sure the length of bootstrap_weights_full be n
  if (length(bootstrap_weights_full) == n)
  {
    return(bootstrap_weights_full)
  }
  else
  {
    stop("the length of bootstrap_weights_full must be n")
  }
}

a = mirror_match_bootstrap_full(syc, N_h_list)
dplyr::glimpse(a)


```

# 5. Finally, we obtain the bootstrap weight matrix by repeating the full bootstrap B times. Bootstrap weight matrix has shape ($n$, B). 
```{r, eval = TRUE, echo = TRUE}
mirror_match_bootstrap_B = function(dataset, N_h_list, B = 100, stratum_list = seq(1, 16))
{
  stratum_vector = dataset$stratum
  bootstrap_weights_matrix = stratum_vector
  for (exp in 1:B)
  {
    bootstrap_weights_vector = mirror_match_bootstrap_full(dataset, N_h_list)
    bootstrap_weights_matrix = cbind(bootstrap_weights_matrix, bootstrap_weights_vector)
  }
   bootstrap_weights_matrix = as.data.frame(bootstrap_weights_matrix)
   names(bootstrap_weights_matrix) = c("stratum", paste0("w", 1:100))
   bootstrap_weights_matrix = subset(bootstrap_weights_matrix, select = -stratum)
  return(bootstrap_weights_matrix)
}

m <- mirror_match_bootstrap_B(syc, N_h_list)
dplyr::glimpse(m)
write.csv(m, "data/bootstrap_weights_matrix.csv", row.names = FALSE)


```


# Appendices




\newpage
# References
  














